package zoneanimation;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.awt.geom.Rectangle2D;

import javax.swing.JPanel;
import javax.swing.event.EventListenerList;

import interfaces.FlecheListener;
import interfaces.GagnantListener;
import interfaces.PositionsEtTempsListener;
import objetsdessinables.ChampElectrique;
import objetsdessinables.CharDassaut;
import objetsdessinables.Projectile;
import objetsdessinables.Terrain;
import objetsdessinables.Vecteur;
import objetsdessinables.VecteurGraphique;

/**
 * classe qui permet le dessin de plusieurs éléments graphiques ainsi que leurs
 * animation
 * 
 * @author léo-paul lapointe
 * @author Andy Lam
 *
 */
public class ZoneDAnimation extends JPanel implements Runnable {

	private static final long serialVersionUID = 1L;

	private final double POS_X_VERT_INIT = 20.0;
	private final double POS_X_ROUGE_INIT = 600.0;
	private final Double TIC_ANGLE_CANON = 0.1;
	private final long TEMPS_SLEEP = 5;
	private final double GRAVITE = 9.8;
	private final double PAS_EULER_REFERENCE = 0.02;
	private final double TEMPS_MAX_CHAMP = 3.0;
	private final double TEMPS_MAX_OBUS = 20.0;
	// private final double RAYON_EXPLOSION = 10.0;
	private final int HAUTEUR_LEGENDE = 10;
	private final int NB_BOND_MAX = 10;
	private final double CHARGE_GRENADE_INIT = 200.0;
	private final int BARRE_ESSENCE_INITIAL = 100;
	private final EventListenerList OBJETS_ENREGISTRES = new EventListenerList();

	private AffineTransform mat;
	private double tailleDuTerrain = 1000.0;
	private double pasEuler = PAS_EULER_REFERENCE;
	private double temps;
	private double bondLegende = 10.0;
	private int masseProjectileVert = 15;
	private double vitesseInitialeVert = 50;
	private int masseProjectileRouge = 15;
	private double vitesseInitialeRouge = 50;

	private double posVertX = 20.0;
	private double posRougeX = 600.0;
	private int barreEssence = BARRE_ESSENCE_INITIAL;
	private int nbPVVert = 3;
	private int nbPVRouge = 3;
	private String nomNiveau;

	private ChampElectrique champ;
	private ModeleAffichage modele;
	private CharDassaut charVert;
	private CharDassaut charRouge;
	private Terrain terrain;
	private Projectile projectile;
	private Vecteur vent;

	private boolean premiereFois = true;
	private boolean explosionChamp = false;
	private boolean tourDuCharVert = true;
	private boolean animEnCours = false;
	private boolean reinitialiser = false;
	private boolean afficherVecteurs = false;
	private boolean ventActive = false;
	private boolean projectileChargePlus = true;
	private boolean estGrenadeElectrique = false;
	private boolean gagnantVert;

	// Andy Lam
	/**
	 * Création de la zone d'animation
	 */
	public ZoneDAnimation() {
		terrain = new Terrain(1000, 1000);
		addKeyListener(new KeyAdapter() {
			@Override
			public void keyPressed(KeyEvent arg0) {
				deplacement(arg0);
				leverEvenPosChar();
				angleCanonFleches(arg0);
			}

			@Override
			public void keyReleased(KeyEvent arg0) {
				eteindreFleches(arg0);
			}
		});

	}

	// Andy Lam
	/**
	 * Méthode qui permet de dessiner toute la zone d'animation
	 * 
	 * @param g
	 *            qui est le contexte graphique
	 * 
	 */
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		Graphics2D g2d = (Graphics2D) g;
		RenderingHints rh = new RenderingHints(RenderingHints.KEY_TEXT_ANTIALIASING,
				RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
		g2d.setRenderingHints(rh);
		modele = new ModeleAffichage(getWidth(), getHeight(), tailleDuTerrain);

		if (premiereFois || reinitialiser) {

			
			if (premiereFois) {
				terrain = new Terrain((int) modele.getLargUnitesReelles(), (int) modele.getHautUnitesReelles());
				
			}
			changeTerrain(nomNiveau);
			charVert = new CharDassaut("tank_vr.png", posVertX,
					terrain.getPointsTerrain((int) (posVertX / terrain.getDx())), terrain.angleSurUnPoint(20, 21), nbPVVert,
					true);
			charRouge = new CharDassaut("tank_rg.png", posRougeX,
					terrain.getPointsTerrain((int) (posRougeX / terrain.getDx())), terrain.angleSurUnPoint(600, 601), nbPVRouge,
					false);
			champ = new ChampElectrique(0, 0, CHARGE_GRENADE_INIT);
			reinitialiser = false;
			premiereFois = false;
		}

		mat = modele.getMatMC();
		if (explosionChamp) {
			// Test pour voir le dessin du champ electrique

			champ.dessiner(g2d, mat);
		}

		terrain.dessiner(g2d, mat);
		charVert.dessiner(g2d, mat);
		charRouge.dessiner(g2d, mat);
		if (animEnCours) {
			projectile.dessiner(g2d, mat);
			affichageVecteurs(g2d);
		}
		// Creation de l'echelle
		g2d.setColor(Color.BLACK);
		while ((tailleDuTerrain / bondLegende) > NB_BOND_MAX) {
			bondLegende += 10.0;
		}
		for (int i = 0; i < (int) Math.round(tailleDuTerrain / bondLegende); i++) {
			g2d.drawString((int) (i * bondLegende) + "m", (float) (Math.round(i * bondLegende) * mat.getScaleX()),
					(getHeight() + Math.round(mat.getScaleX() - HAUTEUR_LEGENDE)));
			Rectangle2D.Double graduation = new Rectangle2D.Double((Math.round(i * bondLegende) * mat.getScaleX()),
					(getHeight() + Math.round(mat.getScaleX() - 3 * HAUTEUR_LEGENDE)), 3, HAUTEUR_LEGENDE);
			g2d.fill(graduation);
		}
		g2d.drawLine(0, (int) (getHeight() + Math.round(mat.getScaleX() - (2.5 * HAUTEUR_LEGENDE))), getWidth(),
				(int) (getHeight() + Math.round(mat.getScaleX() - (2.5 * HAUTEUR_LEGENDE))));

	}
	
	// par léo-paul lapointe
	/**
	 * dessine les vecteurs de forces sur le boulet
	 * 
	 * @param g2d
	 *            qui est le contexte graphique
	 */
	public void affichageVecteurs(Graphics2D g2d) {
		if (afficherVecteurs) {
			// créée et affiche les vecteurs de forces
			VecteurGraphique vecteurGravite = new VecteurGraphique(0, GRAVITE * projectile.getMasseProjectile(),
					projectile.getX() * modele.getPixelsParUniteX(), projectile.getY() * modele.getPixelsParUniteY());
			g2d.setColor(Color.BLUE);
			vecteurGravite.dessiner(g2d, mat);
			if (ventActive) {
				VecteurGraphique vecteurVent = new VecteurGraphique(vent.getX(), vent.getY(),
						projectile.getX() * modele.getPixelsParUniteX(),
						projectile.getY() * modele.getPixelsParUniteY());
				g2d.setColor(Color.RED);
				vecteurVent.dessiner(g2d, mat);
			}
			if (explosionChamp) {
				VecteurGraphique vecteurChamp = new VecteurGraphique(champ.getForceElectrique(projectile).getX(), champ.getForceElectrique(projectile).getX(),
						projectile.getX() * modele.getPixelsParUniteX(),
						projectile.getY() * modele.getPixelsParUniteY());
				g2d.setColor(Color.YELLOW);
				vecteurChamp.dessiner(g2d, mat);
			}
		}
	}

	// Andy Lam
	/**
	 * Methode qui permet de deplacer le char selon la touche appuyee
	 * 
	 * @param arg0
	 *            Le code de la touche de clavier qui a ete appuyee
	 */
	public void deplacement(KeyEvent arg0) {
		if (barreEssence > 0) {

			switch (arg0.getKeyCode()) {
			case (KeyEvent.VK_LEFT):
				leverEventFlecheGauche();
				deplacementGauche();
				break;
			case (KeyEvent.VK_RIGHT):
				leverEventFlecheDroite();
				deplacementDroite();
				break;
			}
		
		}

	}

	// par léo-paul lapointe
	/**
	 * permet de déplacer le canon avec les flèches du clavier
	 * 
	 * @param arg0
	 *            touche enfoncée
	 */
	public void angleCanonFleches(KeyEvent arg0) {
		switch (arg0.getKeyCode()) {
		case (KeyEvent.VK_UP):
			leverEventFlecheHaut();
			monterCanon();
			break;
		case (KeyEvent.VK_DOWN):
			leverEventFlecheBas();
			descendreCanon();
			break;
		}

	}
	
	// par léo-paul lapointe
	/**
	 * permet d'éteingre les fleches directionnelles quand une touche est relachée
	 * 
	 * @param arg0
	 *            touche relachée
	 */
	public void eteindreFleches(KeyEvent arg0) {
		switch (arg0.getKeyCode()) {
		case (KeyEvent.VK_UP):
			leverEventFlecheHautEteindre();
			break;
		case (KeyEvent.VK_DOWN):
			leverEventFlecheBasEteindre();
			break;
		case (KeyEvent.VK_LEFT):
			leverEventFlecheGaucheEteindre();
			break;
		case (KeyEvent.VK_RIGHT):
			leverEventFlecheDroiteEteindre();
			break;
		}
	}

	// par léo-paul lapointe
	/**
	 * permet d'élever le canon du char
	 */
	public void monterCanon() {
		if (tourDuCharVert) {
			if (charVert.getAngleCanon() > -3.2 && charVert.getAngleCanon() < 0.15) {
				charVert.setAngleCanon(charVert.getAngleCanon() - TIC_ANGLE_CANON);
				System.out.println(charVert.getAngleCanon());
			}
		} else {
			if (charRouge.getAngleCanon() > -3.2 && charRouge.getAngleCanon() < 0.15) {
				charRouge.setAngleCanon(charRouge.getAngleCanon() - TIC_ANGLE_CANON);
				System.out.println(charRouge.getAngleCanon());
			}
		}
		repaint();
	}

	// par léo-paul lapointe
	/**
	 * permet de descendre le canon du char
	 */
	public void descendreCanon() {
		if (tourDuCharVert) {
			if (charVert.getAngleCanon() > -3.25 && charVert.getAngleCanon() < 0.1) {
				charVert.setAngleCanon(charVert.getAngleCanon() + TIC_ANGLE_CANON);
				System.out.println(charVert.getAngleCanon());
			}
		} else {
			if (charRouge.getAngleCanon() > -3.25 && charRouge.getAngleCanon() < 0.1) {
				charRouge.setAngleCanon(charRouge.getAngleCanon() + TIC_ANGLE_CANON);
				System.out.println(charRouge.getAngleCanon());
			}
		}
		repaint();
	}

	// Andy Lam
	/**
	 * Methode qui deplace le char selectionnee a droite
	 */
	public void deplacementDroite() {
		if (tourDuCharVert) {
			double nouvPosXDroite = charVert.getX() + (terrain.getDx() / 2);
			if (nouvPosXDroite < tailleDuTerrain - terrain.getDx()
					&& nouvPosXDroite < charRouge.getX() - charVert.getLargeurImgScaled()) {
				charVert.changerPosition(nouvPosXDroite,
						terrain.getPointsTerrain((int) nouvPosXDroite / terrain.getDx()),
						terrain.angleSurUnPoint(((int) charVert.getX()) - (terrain.getDx() / 2), (int) nouvPosXDroite));
			}
		} else {
			double nouvPosXDroite = charRouge.getX() + (terrain.getDx() / 2);
			if (nouvPosXDroite < tailleDuTerrain - terrain.getDx()) {
				charRouge.changerPosition(nouvPosXDroite,
						terrain.getPointsTerrain((int) nouvPosXDroite / terrain.getDx()), terrain.angleSurUnPoint(
								((int) charRouge.getX()) - (terrain.getDx() / 2), (int) nouvPosXDroite));
			}
		}
		barreEssence--;
		repaint();
	}

	// Andy Lam
	/**
	 * Methode qui permet de deplacer le char selectionne vers la gauche
	 */
	public void deplacementGauche() {

		if (tourDuCharVert) {
			double nouvPosXGauche = charVert.getX() - (terrain.getDx() / 2);
			if (nouvPosXGauche > terrain.getDx()) {
				charVert.changerPosition(nouvPosXGauche,
						terrain.getPointsTerrain((int) nouvPosXGauche / terrain.getDx()),
						terrain.angleSurUnPoint((int) charVert.getX() + (terrain.getDx() / 2), (int) nouvPosXGauche));

			}
		} else {
			double nouvPosXGauche = charRouge.getX() - (terrain.getDx() / 2);
			if (nouvPosXGauche > terrain.getDx() && nouvPosXGauche > charVert.getX() + charVert.getLargeurImgScaled()) {
				charRouge.changerPosition(nouvPosXGauche,
						terrain.getPointsTerrain((int) nouvPosXGauche / terrain.getDx()),
						terrain.angleSurUnPoint((int) charRouge.getX() + (terrain.getDx() / 2), (int) nouvPosXGauche));

			}
		}
		barreEssence--;
		repaint();
	}

	// par léo-paul lapointe
	/**
	 * permet de débuter l'animation de tir et le calcul de la trajectoire
	 */
	public void tirer() {
		this.temps = 0;
		if (tourDuCharVert) {
			projectile = new Projectile(charVert.getX(), charVert.getY(), charVert.getAngleCanon(),
					charVert.getAngleTerrain(), vitesseInitialeVert, masseProjectileVert, GRAVITE * masseProjectileVert,
					charVert.getLONGUEUR_CANON(), charVert.getHauteurImgScaled(), estGrenadeElectrique,
					projectileChargePlus);
			projectile.creerAireProjectile(mat);
		} else {
			projectile = new Projectile(charRouge.getX(), charRouge.getY(), charRouge.getAngleCanon(),
					charRouge.getAngleTerrain(), vitesseInitialeRouge, masseProjectileRouge,
					GRAVITE * masseProjectileRouge, charRouge.getLONGUEUR_CANON(), charRouge.getHauteurImgScaled(),
					estGrenadeElectrique, projectileChargePlus);
			projectile.creerAireProjectile(mat);
		}
		demarrer();
	}

	// Andy Lam
	/**
	 * Methode permettant de verifier si une collision a lieu et d'exploser le
	 * projectile
	 */
	public void collisionProjectile() {

		if (animEnCours) {
			Area tempTerrain = new Area(terrain.getAireTerrain());
			Area tempProjectile = new Area(projectile.getAireProjectile());
			tempProjectile.intersect(tempTerrain);
			if (!tempProjectile.isEmpty()) {
				if (!projectile.isGrenadeElectrique()) {
					terrain.explosion(projectile.getX(), projectile.getY() * modele.getPixelsParUniteY(), 50,
							modele.getPixelsParUniteY());
					toucheChar();
					arreter();
					tourDuCharVert = !tourDuCharVert;
					double posXGaucheRouge = charRouge.getX() - (terrain.getDx() / 2);
					double posXGaucheVert = charVert.getX() - (terrain.getDx() / 2);
					charRouge.changerPosition(charRouge.getX(),
							terrain.getPointsTerrain((int) charRouge.getX() / terrain.getDx()), terrain.angleSurUnPoint(
									(int) charRouge.getX() + (terrain.getDx() / 2), (int) posXGaucheRouge));
					charVert.changerPosition(charVert.getX(),
							terrain.getPointsTerrain((int) charVert.getX() / terrain.getDx()), terrain.angleSurUnPoint(
									(int) charVert.getX() + (terrain.getDx() / 2), (int) posXGaucheVert));
					explosionChamp = false;
					barreEssence = BARRE_ESSENCE_INITIAL;
					repaint();
				} else {
					champ.setPosition(projectile.getX(), projectile.getY());
					tourDuCharVert = !tourDuCharVert;
					explosionChamp = true;
					barreEssence = BARRE_ESSENCE_INITIAL;
					arreter();
					repaint();

				}
			} else if (TEMPS_MAX_CHAMP < temps && projectile.isGrenadeElectrique()) {
				champ.setPosition(projectile.getX(), projectile.getY());
				tourDuCharVert = !tourDuCharVert;
				explosionChamp = true;
				barreEssence = BARRE_ESSENCE_INITIAL;
				arreter();
				repaint();
			} else if (TEMPS_MAX_OBUS < temps && !projectile.isGrenadeElectrique()) {
				terrain.explosion(projectile.getX(), projectile.getY() * modele.getPixelsParUniteY(), 50,
						modele.getPixelsParUniteY());
				arreter();
				tourDuCharVert = !tourDuCharVert;
				double posXGaucheRouge = charRouge.getX() - (terrain.getDx() / 2);
				double posXGaucheVert = charVert.getX() - (terrain.getDx() / 2);
				charRouge.changerPosition(charRouge.getX(),
						terrain.getPointsTerrain((int) charRouge.getX() / terrain.getDx()),
						terrain.angleSurUnPoint((int) charRouge.getX() + (terrain.getDx() / 2), (int) posXGaucheRouge));
				charVert.changerPosition(charVert.getX(),
						terrain.getPointsTerrain((int) charVert.getX() / terrain.getDx()),
						terrain.angleSurUnPoint((int) charVert.getX() + (terrain.getDx() / 2), (int) posXGaucheVert));
				explosionChamp = false;
				barreEssence = BARRE_ESSENCE_INITIAL;
				repaint();
			}

		}
	}
	
	// par léo-paul lapointe
	/**
	 * permet de savoir si un char est touché par une explosion
	 */
	public void toucheChar() {
		if (Math.sqrt(Math.pow(Math.abs(charVert.getX() - projectile.getX()), 2)
				+ Math.pow(Math.abs(charVert.getY() - projectile.getY()), 2)) <= 50) {
			charVert.touche();
		}
		if (Math.sqrt(Math.pow(Math.abs(charRouge.getX() - projectile.getX()), 2)
				+ Math.pow(Math.abs(charRouge.getY() - projectile.getY()), 2)) <= 50) {
			charRouge.touche();
			
		}
		if (charVert.getCompteurTouche() == nbPVVert) {
			gagnantVert = false;
			leverEventGagnant();
		}
		else if (charRouge.getCompteurTouche() == nbPVRouge) {
			gagnantVert = true;
			leverEventGagnant();
		}
	}

	// Andy Lam
	// Imcomplet
	/**
	 * Methode permettant de voir un char en mouvement est en collision avec un
	 * autre char
	 * 
	 * @param charEnMouvement
	 *            le char en mouvement
	 * @param charImmobile
	 *            le char immobile qu'on test
	 * @return vrai si le char en mouvement est en collision avec le char immobile
	 */
	public boolean collisionTank(CharDassaut charEnMouvement, CharDassaut charImmobile) {

		return false;
	}

	// par léo-paul lapointe
	/**
	 * animation du projectile
	 */
	@Override
	public void run() {
		while (animEnCours) {
			avancerUnPas(pasEuler);
			try {
				Thread.sleep(TEMPS_SLEEP);
			} catch (InterruptedException e) {
				System.out.println("Processus interrompu!");
			}
		}

	}
	
	// par léo-paul lapointe
	/**
	 * permet d'avancer d'un pas d'euler
	 * 
	 * @param pasEuler
	 *            le pas
	 */
	public void avancerUnPas(double pasEuler) {
		if (ventActive) {
			projectile.accelerationVent(vent, champ.getForceElectrique(projectile), explosionChamp);
		} else {
			projectile.acceleration(champ.getForceElectrique(projectile), explosionChamp);
		}
		projectile.vitesse(pasEuler);
		projectile.position(pasEuler);
		temps = temps + pasEuler;
		leverEvenPosProjectile();
		leverEventVitesseProjectile();
		collisionProjectile();
		leverEvenTemps();
		repaint();
	}

	// par léo-paul lapointe
	/**
	 * créé un nouveau thread et lance le run
	 */
	public void demarrer() {
		if (animEnCours == false) {
			Thread processusAnim = new Thread(this);
			animEnCours = true;
			processusAnim.start();

		}
	}

	// par léo-paul lapointe
	/**
	 * fait mourrir le thread
	 */
	public void arreter() {
		animEnCours = false;
	}

	// par léo-paul lapointe
	/**
	 * permet de changer la masse du projectile
	 * 
	 * @param masse
	 *            la nouvelle masse du projectile
	 */
	public void setMasseProjectile(int masse) {
		if (tourDuCharVert) {
			this.masseProjectileVert = masse;
		} else {
			this.masseProjectileRouge = masse;
		}
	}

	// par léo-paul lapointe
	/**
	 * permet de modifier la vitesse initiale du projectile
	 * 
	 * @param vitesse
	 *            la nouvelle vitesse initiale du projectile
	 */
	public void setVitesseInitiale(double vitesse) {
		if (tourDuCharVert) {
			this.vitesseInitialeVert = vitesse;
		} else {
			this.vitesseInitialeRouge = vitesse;
		}
	}

	// par léo-paul lapointe
	/**
	 * permet de modifier l'angle du canon des chars
	 * 
	 * @param angle
	 *            le nouvel angle en radian
	 */
	public void setAngleCanonSlider(double angle) {
		if (tourDuCharVert) {
			charVert.setAngleCanon(angle);
			repaint();
		}
	}

	// par léo-paul lapointe
	/**
	 * Methode qui retourne la taille reelle du terrain en metre
	 * 
	 * @return La taille reelle du terrain
	 */
	public double getTailleDuTerrain() {
		return tailleDuTerrain;
	}

	// par léo-paul lapointe
	/**
	 * ajoute l'écouteur des déplacements du char et du projectile
	 * @param objEcout
	 */
	public void addCharListener(PositionsEtTempsListener objEcout) {
		OBJETS_ENREGISTRES.add(PositionsEtTempsListener.class, objEcout);
	}

	// par léo-paul lapointe
	/**
	 * ajoute l'écouteur qui change la couleur des fleches
	 * @param objEcout
	 */
	public void addFlecheListener(FlecheListener objEcout) {
		OBJETS_ENREGISTRES.add(FlecheListener.class, objEcout);
	}
	
	// par léo-paul lapointe
	/**
	 * ajoute l'écouteur qui voit si il y a un gagnant
	 * @param objEcout
	 */
	public void addGagnantListener(GagnantListener objEcout) {
		OBJETS_ENREGISTRES.add(GagnantListener.class, objEcout);
	}

	// par léo-paul lapointe
	/**
	 * permet de lever la position du char en x et y
	 */
	private void leverEvenPosChar() {
		for (PositionsEtTempsListener ecout : OBJETS_ENREGISTRES.getListeners(PositionsEtTempsListener.class)) {
			if (tourDuCharVert) {
				ecout.changementPosChar(charVert.getX(), modele.getHautUnitesReelles() - charVert.getY());
			} else {
				ecout.changementPosChar(charRouge.getX(), modele.getHautUnitesReelles() - charRouge.getY());
			}
		}
	}

	// par léo-paul lapointe
	/**
	 * permet de lever la position du projectile en x et y
	 */
	private void leverEvenPosProjectile() {
		for (PositionsEtTempsListener ecout : OBJETS_ENREGISTRES.getListeners(PositionsEtTempsListener.class)) {
			ecout.changementPosProjectile(projectile.getX(), modele.getHautUnitesReelles() - projectile.getY());
		}
	}

	// par léo-paul lapointe
	/**
	 * lève le temps écoulé depuis le début d'un tir
	 */
	private void leverEvenTemps() {
		for (PositionsEtTempsListener ecout : OBJETS_ENREGISTRES.getListeners(PositionsEtTempsListener.class)) {
			ecout.changementTemps(temps);
		}
	}

	// par léo-paul lapointe
	/**
	 * lève la vitesse du projectile
	 */
	private void leverEventVitesseProjectile() {
		for (PositionsEtTempsListener ecout : OBJETS_ENREGISTRES.getListeners(PositionsEtTempsListener.class)) {
			ecout.changementVitesseProjectile(projectile.getVitesse());
		}
	}
	
	// par léo-paul lapointe
	/**
	 * leve si il y a un gagnant
	 */
	private void leverEventGagnant() {
		for (GagnantListener ecout : OBJETS_ENREGISTRES.getListeners(GagnantListener.class)) {
			ecout.declarationGagnant(gagnantVert);
		}
	}
	
	// par léo-paul lapointe
	/**
	 * lève que la fleche du haut est pressée
	 */
	private void leverEventFlecheHaut() {
		for (FlecheListener ecout : OBJETS_ENREGISTRES.getListeners(FlecheListener.class)) {
			ecout.flecheHaut(true);
		}
	}
	
	// par léo-paul lapointe
		/**
		 * lève que la fleche du bas est pressée
		 */
	private void leverEventFlecheBas() {
		for (FlecheListener ecout : OBJETS_ENREGISTRES.getListeners(FlecheListener.class)) {
			ecout.flecheBas(true);
		}
	}
	
	// par léo-paul lapointe
		/**
		 * lève que la fleche de gauche est pressée
		 */
	private void leverEventFlecheGauche() {
		for (FlecheListener ecout : OBJETS_ENREGISTRES.getListeners(FlecheListener.class)) {
			ecout.flecheGauche(true);
		}
	}
	
	// par léo-paul lapointe
		/**
		 * lève que la fleche de droite est pressée
		 */
	private void leverEventFlecheDroite() {
		for (FlecheListener ecout : OBJETS_ENREGISTRES.getListeners(FlecheListener.class)) {
			ecout.flecheDroite(true);
		}
	}
	
	// par léo-paul lapointe
		/**
		 * lève que la fleche du haut est relachée
		 */
	private void leverEventFlecheHautEteindre() {
		for (FlecheListener ecout : OBJETS_ENREGISTRES.getListeners(FlecheListener.class)) {
			ecout.flecheHaut(false);
		}
	}
	
	// par léo-paul lapointe
			/**
			 * lève que la fleche du bas est relachée
			 */
	private void leverEventFlecheBasEteindre() {
		for (FlecheListener ecout : OBJETS_ENREGISTRES.getListeners(FlecheListener.class)) {
			ecout.flecheBas(false);
		}
	}
	
	// par léo-paul lapointe
			/**
			 * lève que la fleche de gauche est relachée
			 */
	private void leverEventFlecheGaucheEteindre() {
		for (FlecheListener ecout : OBJETS_ENREGISTRES.getListeners(FlecheListener.class)) {
			ecout.flecheGauche(false);
		}
	}
	
	// par léo-paul lapointe
			/**
			 * lève que la fleche de droite est relachée
			 */
	private void leverEventFlecheDroiteEteindre() {
		for (FlecheListener ecout : OBJETS_ENREGISTRES.getListeners(FlecheListener.class)) {
			ecout.flecheDroite(false);
		}
	}

	// par léo-paul lapointe
	/**
	 * permet de modifier le pas d'euler
	 * 
	 * @param pasEuler
	 *            le nouveau pas
	 */
	public void setPasEuler(double pasEuler) {
		this.pasEuler = pasEuler;
	}

	// par léo-paul lapointe
	/**
	 * retourne le pas d'euler de référence
	 * 
	 * @return le pas d'euler de référence
	 */
	public double getPAS_EULER_REFERENCE() {
		return PAS_EULER_REFERENCE;
	}
	
	
	public void setVent(Vecteur vent) {
		this.vent = vent;
	}

	// Andy Lam
	/**
	 * méthode qui permet de reinitialiser tous les composants de la zone
	 * d'animation à ses valeurs initiales et les redessine
	 */
	public void reinitialiser() {
		if (!reinitialiser) {
			reinitialiser = true;
			tourDuCharVert = true;
			posRougeX = POS_X_ROUGE_INIT;
			posVertX = POS_X_VERT_INIT;

			repaint();
		}
	}

	// par léo-paul lapointe
	/**
	 * permet de modifier l'affichage ou non des vecteurs de forces
	 * 
	 * @param afficherVecteurs
	 *            la nouvelle valeur boolean
	 */
	public void setAfficherVecteurs(boolean afficherVecteurs) {
		this.afficherVecteurs = afficherVecteurs;
	}

	// par léo-paul lapointe
	/**
	 * retourne si oui ou non les vecteurs seont affichés
	 * 
	 * @return oui ou non les vecteurs seont affichés
	 */
	public boolean isAfficherVecteurs() {
		return afficherVecteurs;
	}
	
	// par léo-paul lapointe
	/**
	 * Méthode qui permet de regarder si le vent va affecté le projectile
	 * @return vrai si le projectile va être affecté 
	 */
	public boolean isVentActive() {
		return ventActive;
	}
	
	// par léo-paul lapointe
	/**
	 * retoure si oui ou non le projectile est une grenade électrique
	 * @return si oui ou non le projectile est une grenade électrique
	 */
	public boolean isGrenageElectrique() {
		return projectile.isGrenadeElectrique();
	}
	
	// par léo-paul lapointe
	/**
	 * permet de choisir si le vent est actif ou pas
	 * @param ventActive vrai si on veut que le projectile soit affecté par le vent
	 */
	public void setVentActive(boolean ventActive) {
		this.ventActive = ventActive;
	}

	// par léo-paul lapointe
	/**
	 * permet de modifier la charge du projectile entre plus ou moins
	 * @param projectileChargePlus si c'est une charge plus
	 */
	public void setProjectileChargePlus(boolean projectileChargePlus) {
		this.projectileChargePlus = projectileChargePlus;
	}
	/**
	 * Méthode qui permet de changer le terrain
	 */
	public void changeTerrain(String choixTerrain) {
		nomNiveau = choixTerrain;
		terrain.changePointsTerrain(choixTerrain);
		switch (choixTerrain) {
		case "Terre":
			break;
		case "Lune":
			break;
		case "Mars":
			break;
		case "Uranus":
			break;
		}
		repaint();
	}
	
	// par léo-paul lapointe
	/**
	 * permet de décider si le projectile est une grenade électrique ou pas
	 * @param estGrenadeElectrique
	 */
	public void setEstGrenadeElectrique(boolean estGrenadeElectrique) {
		this.estGrenadeElectrique = estGrenadeElectrique;
	}
	
	// par léo-paul lapointe
	/**
	 * Méthode qui retourne la valeur  de la barre d'essence 
	 * @return la valeur de la barre d'essence
	 */
	public int getBarreEssence() {
		return barreEssence;
	}

}
